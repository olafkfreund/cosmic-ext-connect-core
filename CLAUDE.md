# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

`cosmic-ext-connect-core` is a pure Rust implementation of the KDE Connect protocol v7, designed as a cross-platform shared library via FFI (Foreign Function Interface). This library powers both:
- **COSMIC Connect Android app** (via Kotlin bindings)
- **COSMIC Desktop applet** (direct Rust usage)

The project is currently in **Phase 0: Rust Core Extraction** - actively extracting protocol implementation from the COSMIC Desktop applet into this shared library.

## Build and Test Commands

### Building

```bash
# Build the library
cargo build

# Build release version
cargo build --release

# Build for specific Android target
cargo build --target aarch64-linux-android --release
```

### Testing

```bash
# Run all tests
cargo test

# Run specific module tests
cargo test --package cosmic-ext-connect-core --lib protocol::tests
cargo test --package cosmic-ext-connect-core --lib network::discovery::tests

# Run tests with logging output
RUST_LOG=debug cargo test

# Run a single test
cargo test test_packet_serialization
```

### UniFFI Bindings Generation

```bash
# Generate Kotlin bindings (for Android)
cargo run --bin uniffi-bindgen generate src/cosmic_ext_connect_core.udl --language kotlin --out-dir ./bindings/kotlin

# Generate Swift bindings (for iOS)
cargo run --bin uniffi-bindgen generate src/cosmic_ext_connect_core.udl --language swift --out-dir ./bindings/swift
```

### Code Quality

```bash
# Check for compilation errors without building
cargo check

# Run clippy for lints
cargo clippy

# Format code
cargo fmt
```

## Architecture

### Layer Structure

The codebase is organized into distinct layers:

1. **Protocol Layer** (`src/protocol/`)
   - Core types: `Packet`, `Device`, `Identity`
   - JSON serialization with newline terminators (KDE Connect requirement)
   - Packet IDs are UNIX timestamps in milliseconds
   - Handles both string and number ID formats for compatibility

2. **Network Layer** (`src/network/`)
   - UDP broadcast discovery on port 1716
   - TCP/TLS transport with rustls (NO OpenSSL - for Android cross-compilation)
   - Port range fallback: 1716-1764 if primary port unavailable

3. **Crypto Layer** (`src/crypto/`)
   - Certificate management using `rcgen` and `rustls`
   - Self-signed certificates with SHA-256 fingerprints
   - TLS configuration for secure device pairing

4. **Plugin Layer** (`src/plugins/`)
   - Trait-based plugin architecture
   - Protocol logic and state management in Rust core
   - Platform-specific code (UI, system APIs) stays in Kotlin/Swift
   - Plugins: `ping`, `battery`, `share`, etc.

5. **FFI Layer** (`src/ffi/`)
   - uniffi-rs bindings for cross-platform use
   - UDL file: `src/cosmic_ext_connect_core.udl` defines the FFI boundary
   - Scaffolding auto-generated by `build.rs` during compilation

### Key Architectural Patterns

**Separation of Concerns:**
- Rust core handles protocol logic, state, and business rules
- Platform code (Android/Desktop) handles UI and system integration
- FFI boundary defined explicitly in `.udl` file

**Error Handling:**
- Custom `ProtocolError` type using `thiserror`
- FFI-compatible error variants
- Result type: `type Result<T> = std::result::Result<T, ProtocolError>`

**Async Architecture:**
- Built on `tokio` async runtime
- Plugins use `async_trait`
- Discovery service uses async channels for event handling

**Plugin System:**
- All plugins implement the `Plugin` trait
- Lifecycle: Construction → Registration → Initialization → Operation → Shutdown
- Plugins advertise capabilities (incoming/outgoing packet types)
- `PluginManager` routes packets to appropriate plugins

## Important Technical Details

### KDE Connect Protocol Specifics

**Packet Format:**
- JSON object terminated with `\n` (newline)
- Field names: `id`, `type`, `body`, `payloadSize` (optional), `payloadTransferInfo` (optional)
- Packet types follow pattern: `kdeconnect.<plugin>[.<action>]`
- Example: `kdeconnect.battery`, `kdeconnect.mpris.request`

**Discovery Protocol:**
1. Broadcast identity packet via UDP on port 1716
2. Listen for identity packets from other devices
3. Track device presence with timeouts
4. Device IDs are UUIDs with underscores (e.g., `abc123_def456_...`)

**Identity Packet Fields (order matters):**
- `deviceId`: UUID with underscores
- `deviceName`: Human-readable name (1-32 chars)
- `protocolVersion`: Currently 7
- `deviceType`: "desktop", "laptop", "phone", "tablet", "tv"
- `tcpPort`: Port for TCP connections
- `incomingCapabilities`: Packet types device can receive
- `outgoingCapabilities`: Packet types device can send

### TLS and Certificate Management

**Why rustls, not OpenSSL:**
- Easier Android cross-compilation
- No C dependency management
- Pure Rust implementation

**Certificate Requirements:**
- Self-signed X.509 certificates
- Generated using `rcgen` crate
- SHA-256 fingerprints for device verification
- Subject name matches device ID

### FFI Boundary (UniFFI)

**Type Mappings:**
- UDL `string` → Kotlin `String` / Swift `String`
- UDL `i64` → Kotlin `Long` / Swift `Int64`
- UDL `bytes` → Kotlin `ByteArray` / Swift `Data`
- UDL `sequence<T>` → Kotlin `List<T>` / Swift `[T]`

**Callbacks:**
- `DiscoveryCallback`: Platform implements to receive discovery events
- `PluginCallback`: Platform implements to receive plugin events

**Build Process:**
1. `build.rs` runs `uniffi::generate_scaffolding()` at compile time
2. Reads `src/cosmic_ext_connect_core.udl`
3. Generates Rust scaffolding code
4. Platform bindings generated separately via `uniffi-bindgen` CLI

## Development Workflow

### Adding a New Plugin

1. Create plugin file in `src/plugins/your_plugin.rs`
2. Implement the `Plugin` trait with `#[async_trait]`
3. Define `incoming_capabilities()` and `outgoing_capabilities()`
4. Implement `handle_packet()` for packet processing
5. Add to `src/plugins/mod.rs`
6. If needed, add FFI functions to `src/ffi/mod.rs` and `src/cosmic_ext_connect_core.udl`
7. Update `PluginManager` if plugin needs special operations

### Modifying Protocol Types

1. Update Rust structs in `src/protocol/`
2. Update serialization/deserialization logic
3. Add tests for roundtrip compatibility
4. If exposed via FFI: update `.udl` file and regenerate bindings
5. Test with actual KDE Connect devices for compatibility

### Testing Strategy

- **Unit tests**: In same file as implementation (`#[cfg(test)]` module)
- **Integration tests**: Test full packet flow end-to-end
- **Roundtrip tests**: Ensure serialize→deserialize preserves data
- **FFI tests**: Test type conversions across FFI boundary
- **Compatibility tests**: Verify against actual KDE Connect implementations

## Common Patterns

### Creating and Sending Packets

```rust
use cosmic_ext_connect_core::protocol::Packet;
use serde_json::json;

// Create packet
let packet = Packet::new("kdeconnect.ping", json!({}));

// Serialize with newline terminator
let bytes = packet.to_bytes()?;
assert_eq!(bytes.last(), Some(&b'\n'));
```

### Builder Pattern Usage

```rust
let packet = Packet::new("kdeconnect.identity", json!({}))
    .with_body_field("deviceId", "test-device")
    .with_body_field("deviceName", "Test Device")
    .with_payload_size(1024);
```

### Error Construction

```rust
// Use helper methods
return Err(ProtocolError::network("Connection refused"));

// Or construct directly
return Err(ProtocolError::InvalidPacket("Missing field".to_string()));
```

### Plugin Implementation Template

```rust
use async_trait::async_trait;
use crate::plugins::Plugin;
use crate::protocol::Packet;
use crate::error::Result;

pub struct YourPlugin {
    name: String,
    // ... state fields
}

#[async_trait]
impl Plugin for YourPlugin {
    fn name(&self) -> &str { &self.name }

    fn incoming_capabilities(&self) -> Vec<String> {
        vec!["kdeconnect.yourplugin".to_string()]
    }

    fn outgoing_capabilities(&self) -> Vec<String> {
        vec!["kdeconnect.yourplugin".to_string()]
    }

    async fn handle_packet(&mut self, packet: &Packet) -> Result<()> {
        // Process packet
        Ok(())
    }

    async fn initialize(&mut self) -> Result<()> { Ok(()) }
    async fn shutdown(&mut self) -> Result<()> { Ok(()) }
}
```

## Troubleshooting

### Port Binding Issues

If discovery fails to bind to port 1716:
- The code automatically tries fallback ports 1717-1764
- Check system firewall rules
- Verify no other KDE Connect service is running

### Cross-Compilation for Android

Required targets:
```bash
rustup target add aarch64-linux-android
rustup target add armv7-linux-androideabi
rustup target add i686-linux-android
rustup target add x86_64-linux-android
```

Set up Android NDK path in environment or `.cargo/config.toml`

### UniFFI Binding Generation

If bindings fail to generate:
- Ensure `.udl` file syntax is valid
- Check that all types referenced in UDL are defined
- Verify uniffi version matches in `Cargo.toml` and `build.rs`

## Current Development Status

### Completed (Phase 0)
- ✅ Project structure and module organization
- ✅ Cargo configuration with rustls and uniffi
- ✅ Error type system (ProtocolError)
- ✅ NetworkPacket implementation (Issue #45)
- ✅ Discovery service (Issue #46)
- ✅ TLS transport with rustls (Issue #47)
- ✅ Certificate generation with rcgen (Issue #48)
- ✅ Plugin trait design (Issue #49)

### In Progress
- ⏳ Creating uniffi FFI bindings (Issue #50)
- ⏳ Implementing plugin system components
- ⏳ Testing with actual KDE Connect devices

## Resources

- KDE Connect Protocol: https://invent.kde.org/network/kdeconnect-kde
- Valent Protocol Reference: https://valent.andyholmes.ca/documentation/protocol.html
- uniffi-rs Documentation: https://mozilla.github.io/uniffi-rs/
- rustls Documentation: https://docs.rs/rustls/
- COSMIC Desktop: https://github.com/pop-os/cosmic-epoch

## License

Dual-licensed under GPL-2.0-or-later OR GPL-3.0-or-later
